<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>Yet Another Archetypal ECS Rust Implementation</title><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,600;1,600&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Prompt:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Roboto+Mono:ital,wght@0,500;1,500&family=Sankofa+Display&display=swap" rel=stylesheet><style>body{--primary-color:#5871a2;--primary-pale-color:#5871a210;--text-color:#3c4043;--text-pale-color:#94969f;--bg-color:#fff;--highlight-mark-color:#5f75b035;--callout-note-color:#5871a2;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460;--main-font:"Roboto Mono",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:"Roboto Mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:1200px;--main-max-width:1200px;--avatar-size:60px;--icon-size:20px;--homepage-font-size:16px;--homepage-line-height:1.5;--paragraph-font-size:16px;--paragraph-line-height:1.5;--aside-font-size:15px;--img-border-radius:0;--callout-border-radius:0;--detail-border-radius:0;--dark-mode-img-brightness:1.0;--dark-mode-chart-brightness:1.0;--inline-code-border-radius:2px;--inline-code-bg-color:var(--primary-pale-color);--block-code-border-radius:0;--code-font-size:15px;--block-code-border-color:var(--primary-color);--detail-border-color:var(--primary-color)}body.dark{--primary-color:#ce79d6;--primary-pale-color:#8d5dac20;--text-color:#9197a5;--text-pale-color:#747983;--bg-color:#232529;--highlight-mark-color:#5f75b035;--callout-note-color:#ba70d8;--callout-important-color:#9571cf;--callout-warning-color:#babb69;--callout-alert-color:#f36060;--callout-question-color:#477389;--callout-tip-color:#3c8460}</style><link href=/main.css rel=stylesheet><link href=/hl-light.css id=hl rel=stylesheet><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV rel=stylesheet><script crossorigin defer integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script crossorigin defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false},{left:'\\[',right:'\\]',display:true}],throwOnError:false})})</script><body class=post><script>const theme=sessionStorage.getItem('theme');const match=window.matchMedia("(prefers-color-scheme: dark)").matches;if(theme&&theme=='dark'||!theme&&match){document.body.classList.add('dark');const a=document.querySelector('link#hl');if(a)a.href='/hl-dark.css'}</script><header class=blur><div id=header-wrapper><nav><a class=instant href=/>Jed037</a><button aria-label="toggle expand" class=separator id=toggler>::</button><span class="wrap left fold">{</span><a class="instant fold" href=/projects>projects</a><span class="wrap-separator fold">,</span><a class="instant fold" href=/about>about</a><span class="wrap right fold">} ;</span></nav><div id=btns><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>' id=theme-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><div id=wrapper><div id=blank></div><aside><nav><ul><li><a class=h2 href=#intro>Intro</a><li><a class=h2 href=#entities>Entities</a> <ul><li><a class=h3 href=#example>Example</a></ul><li><a class=h2 href=#components>Components</a> <ul><li><a class=h3 href=#example-1>Example</a></ul><li><a class=h2 href=#systems>Systems</a><li><a class=h2 href=#initial-naive-implementation>Initial Naive Implementation</a><li><a class=h2 href=#intro-to-archetypes>Intro to archetypes</a> <ul><li><a class=h3 href=#component-layout-example>Component Layout Example</a></ul><li><a class=h2 href=#memory-heap-allocation-optimization>Memory Heap Allocation Optimization</a><li><a class=h2 href=#query-system>Query system</a> <ul><li><a class=h3 href=#multithreading-and-vectorization>Multithreading and Vectorization</a></ul><li><a class=h2 href=#change-add-removal-detection>Change/Add/Removal Detection</a> <ul><li><a class=h3 href=#initial-implementation>Initial implementation</a><li><a class=h3 href=#column-based-optimization>Column based optimization</a></ul><li><a class=h2 href=#conclusion>Conclusion</a></ul></nav><button aria-label="back to top" id=back-to-top><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill=currentColor></path></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1>Yet Another Archetypal ECS Rust Implementation</h1><div id=post-info><div id=date><span id=publish>2023-09-16</span></div><div id=tags><a class=instant href=https://jedjoud10.github.io/tags/game-dev><span>#</span>game-dev</a><a class=instant href=https://jedjoud10.github.io/tags/ecs><span>#</span>ecs</a><a class=instant href=https://jedjoud10.github.io/tags/custom-engine><span>#</span>custom-engine</a></div></div><h1 id=intro>Intro<a aria-label="Anchor link for: intro" class=zola-anchor href=#intro style=visibility:hidden>#</a></h1><p>One of the first problems I encountered when making my game engine was how to handle game logic. I was already familiar with Unity’s GameObject and Component system, where your game world would contain multiple “GameObjects” that each have their own “Components” that would apply specific game logic to their owning objects (or others in the world).</p><center>Example of a GameObject / Component type system</center><pre class=mermaid>
  %%{ init: { 'flowchart': { 'curve': 'stepBefore' } } }%%
flowchart LR
A[Game World]
A --> GM1[Game Object 1]
A --> GM2[Game Object 1]
A --> GM3[Game Object 1]
GM1 --> C1[Component 1]
GM1 --> C2[Component 2]
GM2 --> C3[Component 1]
GM3 --> C4[Component 2]
</pre><p>This method works fine for the most part, but scales terribly when you have thousands of components that have computationally expensive logic. This also makes parallelism and multithreading a bit more complicated since you can’t easily parallelize a lot of cheap operations.<blockquote class="callout note"><div class=icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" fill=currentColor></path></svg></div><div class=content><p><strong>Note</strong><p>Unity DOTS and Unity ECS fix this completely since they use both multithreading and SIMD, but using their Job System.</div></blockquote><p>So, for my game engine, I decided to implement a common (if not over-used) technique to alleviate these kind of problems: ECS ECS stands for Entity Component System, and it is an architectural pattern in use by game engines for handling a lot of game objects using multithreading safe methods. I am pretty sure that there are a multitude of articles and resources that explain how and why it is better for performance in general, but here’s my shot at explaining it. ECS is <em>usually</em> split into three parts: <strong>Entities</strong>, <strong>Components</strong>, and <strong>Systems</strong>.<h1 id=entities>Entities<a aria-label="Anchor link for: entities" class=zola-anchor href=#entities style=visibility:hidden>#</a></h1><p>Entities are simply just <em>handles</em>, like pointers, that point to something stored internally within the core of the engine. You can think of them as simple <code>u64</code> integers or even a hexadecimal value (<code>0x32</code>).<h2 id=example>Example<a aria-label="Anchor link for: example" class=zola-anchor href=#example style=visibility:hidden>#</a></h2><p>For example, any of these following values could be considered an entity<table><thead><tr><th>0x01<th>2<th>'E'<th>0b0001<th>4294967295<tbody></table><p>As long as the values are unique and represent an integer at the end, these could all be used as <code>Entity IDs</code> (albeit it would be cursed to have a <code>char</code> be an entity ID lol)<h1 id=components>Components<a aria-label="Anchor link for: components" class=zola-anchor href=#components style=visibility:hidden>#</a></h1><p>Components contain the data that is pointed to by each entity. Multiple components can be applied to entities, but there can only be one component “type” that can be applied to a single entity.<p>To be able to use our components internally, we must "indentify" each component from every other component. The simplest way to do this is to have a unique number (<em>or unique value really</em>) that is applied to each component type. How I handled this in my system is by So basically, we just have to think of our components as if they were an offset (left shift) of a singular bit inside a <code>u64</code>, which would differentiate them from every other component. Something like this basically:<table><thead><tr><th>Component<th>ID Bitmask<tbody><tr><td>Transform<td>0b001<tr><td>Health<td>0b010<tr><td>Player<td>0b100</table><p>These values could be calculated with the following function (<em>as long as you know the column index of each component</em>)<pre class="language-rs z-code" data-lang=rs><code class=language-rs data-lang=rs><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> </span><span class="z-entity z-name z-function z-rust">bitmask</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span>T<span class="z-punctuation z-separator z-rust">:</span> Component<span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-storage z-type z-rust">u64</span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> "Column" index. Basically just an integer that
</span>    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> is incremented for every new component that we register 
</span>    <span class="z-storage z-type z-rust">let</span> index <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-meta z-path z-rust">T<span class="z-punctuation z-accessor z-rust">::</span></span>index<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
    
    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Left shift by the index to create a unique bitmask
</span>    <span class="z-keyword z-control z-rust">return</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span> <span class="z-keyword z-operator z-comparison z-rust"><</span><span class="z-keyword z-operator z-comparison z-rust"><</span> index<span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><h2 id=example-1>Example<a aria-label="Anchor link for: example-1" class=zola-anchor href=#example-1 style=visibility:hidden>#</a></h2><p>For example, I have this table over here that depicts my entities and components in my scene. I can apply a “Transform” component onto entity 01, and the “Health” and “Player” components onto entity 02, however, I cannot apply the “Player” component again into entity 02, since it was already applied. (using this table to represent our data makes understanding <code>archetypes</code> a lot easier later on)<table><thead><tr><th>Entities<th>Transform<th>Health<th>Player<tbody><tr><td>Entity 01<td>X<td><td><tr><td>Entity 02<td><td>X<td>X</table><p>These following structs could be a reasonable representation of the components above<pre class="language-rs z-code" data-lang=rs><code class=language-rs data-lang=rs><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Position, rotation, and scale; all composited into one component
</span><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">derive</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">Component</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
<span class="z-meta z-struct z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Transform</span> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">position</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust">Vec3<span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-rust">f32</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span>,
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">rotation</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-meta z-generic z-rust">Quaternion<span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-rust">f32</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span>,
    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-variable z-other z-member z-rust">scale</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-storage z-type z-rust">f32</span>
</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>

<span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Entity health component
</span><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">derive</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">Component</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
<span class="z-meta z-struct z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Health</span></span><span class="z-meta z-struct z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-type z-rust">f32</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>

<span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Components don't *need* to store data. They could be used for flagging entities for example
</span><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">derive</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">Component</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
<span class="z-meta z-struct z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Player</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre><h1 id=systems>Systems<a aria-label="Anchor link for: systems" class=zola-anchor href=#systems style=visibility:hidden>#</a></h1><p>Systems handle logic. They iterate over entities or components and view them (read) or mutate (write) them using custom user implemented logic. This is what makes ECS easily <strong>multithreadable</strong>, since you would only need to turn this “Iteration” parallel (in Rust this is easily doable using the <a rel="nofollow noreferrer" href=https://crates.io/crates/rayon><code>Rayon</code></a> crate and the <code>par_iter()</code> or <code>par_bridge()</code> methods, which I will talk about a bit later on). Within my system I implement these as “queries'' that return an <code>Iterator&LTT></code> over the components I wish to view or mutate.<h1 id=initial-naive-implementation>Initial Naive Implementation<a aria-label="Anchor link for: initial-naive-implementation" class=zola-anchor href=#initial-naive-implementation style=visibility:hidden>#</a></h1><p>My initial implementation of ECS was quite scruffy however; it was solely single threaded, and was very naive. All I did was store a hashmap of unique <code>u64</code>s, which are my entities, and store a <code>Vec&LTBox&LTdyn Component>></code> where <code>Component</code> is a trait implemented for each struct that I want to treat as a component. This worked fine at first but it scaled horribly. First of all it didn’t “feel” like proper ECS. After all, one of the main selling points of ECS is fast iteration and parallelization, but in this system, none of those were available at impressive speeds. So after looking at how normal ECS libraries like <a rel="nofollow noreferrer" href=https://github.com/skypjack/entt><code>entt</code></a>, <a rel="nofollow noreferrer" href=https://docs.rs/hecs/latest/hecs/><code>hecs</code></a>, <a rel="nofollow noreferrer" href=https://docs.rs/bevy_ecs/latest/bevy_ecs/><code>bevy_ecs</code></a> and <a rel="nofollow noreferrer" href=https://github.com/amethyst/specs><code>specs</code></a> crates did it, I gave it another shot.<h1 id=intro-to-archetypes>Intro to archetypes<a aria-label="Anchor link for: intro-to-archetypes" class=zola-anchor href=#intro-to-archetypes style=visibility:hidden>#</a></h1><p>Instead of storing each component of my entities, per entity, I decided to implement a pattern called the <code>archetype</code>s system. This system groups each entity based on the types of <code>component</code>s that it contains, or so called, its component “layout”. So entities with similar component “layouts” will be grouped in the same archetype (where component "layout" simply means an identifier for each combination of component stored on the entity).<h2 id=component-layout-example>Component Layout Example<a aria-label="Anchor link for: component-layout-example" class=zola-anchor href=#component-layout-example style=visibility:hidden>#</a></h2><p>For example, here is a table that represents our entities and components that are applied to them<table><thead><tr><th>Entities<th>Transform<th>Health<th>Player<tbody><tr><td>Entity 01<td>X<td><td><tr><td>Entity 02<td><td>X<td>X</table><p>assume that each component column (<code>Transform</code>, <code>Health</code>, <code>Player</code>), has an index to it that is incremented by one for each column. So the <code>Transform</code> column would have an index of 0, <code>Health</code> column would have an index of 1, <code>Player</code> column would have an index of 2 and so forth. We can calculate the component layout for each entity by simply marking what components are applied to it, which would look something like this (I will also show the component column index as well)<table><thead><tr><th>Entities<th>Component Layout<tbody><tr><td>Entity 01<td>Transform (0)<tr><td>Entity 02<td>Health (1), Player (2)</table><p>to calculate a unique identitifer for each combination of components, we can treat our component column indices as active bits inside a <code>bitmask</code>! So for <code>Entity 01</code>, the layout would be <code>0b001</code>, since the 0th bit is enabled and no other bits (or components) are active.<p>For <code>Entity 02</code>, the layout would be <code>0b110</code>, because it has the <code>Health</code> component (index of 1) and <code>Player</code> component (index of 2) (so, we must active the bits at indices 1 and 2, which gives us <code>0b110</code>)<table><thead><tr><th>Entities<th>Bitmask Layout<tbody><tr><td>Entity 01<td>0b001<tr><td>Entity 02<td>0b110</table><p>The components will actually be stored within the corresponding archetype instead of loosely fitted somewhere in memory, which should improve performance. Whenever you add a component onto an entity, it calculates the new component <code>layout</code> (its bitmask) for the entity and “moves” it into the corresponding archetype (with the proper <code>bitmask</code> layout).<p>So in our example above, we'd have two archetypes, each containing one entity each. You'd have the archetype <code>0b001</code>, that contains entities that <em>only</em> contain the <code>Transform</code> component, and the archetype <code>0b110</code>, that only contains entities that have the <code>Health</code> and <code>Player</code> components. Something like this basically:<table><thead><tr><th>Archetypes<th>Entities<tbody><tr><td>0b001<td>[Entity 01]<tr><td>0b110<td>[Entity 02]</table><br><br><center>Example of two archetypes containing a single entity each</center><pre class=mermaid>
  %%{ init: { 'flowchart': { 'curve': 'stepBefore' } } }%%
flowchart LR
A[Game World]
A --> AR1[Archetype 0b001]
A --> AR2[Archetype 0b110]
AR1 --> EG1
AR1 --> CG1
AR2 --> EG2
AR2 --> CG2

subgraph EG1[Entities]
E1[Entity 1]
end
subgraph CG1[Components]
CC1[Transform]
end

subgraph EG2[Entities]
E2[Entity 2]
end
subgraph CG2[Components]
CC2[Health]
CC3[Player]
end
</pre><center>Example of a single archetype containing 3 entities with 2 components each</center><pre class=mermaid>
  %%{ init: { 'flowchart': { 'curve': 'stepBefore' } } }%%
flowchart LR
A[Game World]
A --> AR1[Archetype 0b011]
AR1 --> EG1
AR1 --> CG1

subgraph EG1[Entities]
E1[Entity 1]
E2[Entity 2]
E3[Entity 3]
end
subgraph CG1[Components]

subgraph ACC1[Transform Components]
CC1[Transform]
CC2[Transform]
CC3[Transform]
end

subgraph ACC2[Health Components]
CC4[Health]
CC5[Health]
CC6[Health]
end

end
</pre><p>And finally, here's an actual archetype list from within <code>cFlake</code> engine <img alt="Simple Archetypes" src=/simple_archetypes.png><p>and here's a more complex case when loading the basic GTLF example <img alt="Multiple Archetypes" src=/multiple_archetypes.png><h1 id=memory-heap-allocation-optimization>Memory Heap Allocation Optimization<a aria-label="Anchor link for: memory-heap-allocation-optimization" class=zola-anchor href=#memory-heap-allocation-optimization style=visibility:hidden>#</a></h1><p>By only allocating one archetype per component layout, we know beforehand what are the components we will store within them (due to their layout, which tells us the adequate components we will store eventually). As such, we can pre-allocate or deallocate memory that we do not need when needed. Another optimization you can do to further reduce heap allocations is instead of storing a <code>Vec&LTBox&LTdyn Component>></code> (2 heap allocations: [<code>Vec<_></code>, <code>Box<_></code>], and the secondary one scales with the number of components), you could instead store a boxed trait object <code>Box&LTdyn VecStorage></code> where <code>VecStorage</code> is implemented for every <code>Vec&LTT> where T: Component</code> (which reduces heap allocations to only two in total, no matter the number of components). This reduces your memory consumption by a lot compared to the previous because we aren’t constructing a dynamically dispatchable object for every component. Not only that, but it fits everything very tightly in memory, which also improves querying / iteration speeds, which is our next topic.<h1 id=query-system>Query system<a aria-label="Anchor link for: query-system" class=zola-anchor href=#query-system style=visibility:hidden>#</a></h1><p>I made a simple “query” system (inspired, if not directly copied, from Bevy’s query system) that would allow you to iterate over any arbitrary mix of components stored in the world (through the help of tuples). So I could do something like the following:<pre class="language-rs z-code" data-lang=rs><code class=language-rs data-lang=rs><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Iterating an immutable query that views all entities
</span><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> that have the Player component (immut) and Health component (immut)
</span><span class="z-keyword z-control z-rust">for</span> <span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>player<span class="z-punctuation z-separator z-rust">,</span> health</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-rust">in</span> ecs<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-meta z-generic z-rust">query<span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-operator z-rust">&</span>Player, <span class="z-keyword z-operator z-rust">&</span>Health<span class="z-punctuation z-section z-group z-end z-rust">)</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> ...
</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>

<span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Mutable query that iterates over all entities with the Transform component (mutable)
</span><span class="z-keyword z-control z-rust">for</span> transform <span class="z-keyword z-operator z-rust">in</span> ecs<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-meta z-generic z-rust">query_mut<span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-keyword z-operator z-rust">&</span><span class="z-storage z-modifier z-rust">mut</span> Transform<span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> ...
</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></code></pre><h2 id=multithreading-and-vectorization>Multithreading and Vectorization<a aria-label="Anchor link for: multithreading-and-vectorization" class=zola-anchor href=#multithreading-and-vectorization style=visibility:hidden>#</a></h2><p>By storing all my components within a vector for each component type, I can enable simple vectorization by looping over it normally, like any Rust iterator. I don’t have to deal with the old janky system of iterating through the entities, then fetching their components separately. This also meant this could be easily multithreaded by the help of the commonly used <a rel="nofollow noreferrer" href=https://crates.io/crates/rayon><code>Rayon</code></a> crate, which turns your simple threaded iteration code into multithreaded code very easily. This also makes multithreaded iteration extremely similar to single threaded iteration (the only caveat at the moment is the need to convert to an intermediate <code>Vec&LTT></code>, but this could be fixed if you implement <code>Rayon</code>'s <code>ParallelIterator</code> trait for all <code>Query</code> types).<pre class="language-rs z-code" data-lang=rs><code class=language-rs data-lang=rs><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Mutable query that iterates over all entities with the Transform component (mutable)
</span><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Need to convert to intermediate Vec<_> because I still haven't implement the ParallelIterator
</span><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> trait to my query types
</span><span class="z-storage z-type z-rust">let</span> temp <span class="z-keyword z-operator z-assignment z-rust">=</span> ecs<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-meta z-generic z-rust">query_mut<span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-keyword z-operator z-rust">&</span><span class="z-storage z-modifier z-rust">mut</span> Transform<span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">into_iter</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-meta z-path z-rust">collect<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Vec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-keyword z-operator z-rust">_</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>

<span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Iterating over the vector in parallel (super fast, since all &mut references are linear in memory anyways)
</span>temp<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">into_par_iter</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">for_each</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">|</span></span></span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-variable z-parameter z-rust">transform</span><span class="z-punctuation z-section z-parameters z-end z-rust">|</span></span> </span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> ...
</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></code></pre><p>Now unfortunately due to the nature of my game engine's world management (a global <code>World</code> that you'd access) there is no way to multithread adding multiple <code>Entities</code> or registering <code>Archetypes</code> (<em>but even then, it wouldn't matter because there would an internal lock to keep things sequential, unless you make a copy fragment of the world on each thread, which would be an interesting thing to look into imo</em>)<h1 id=change-add-removal-detection>Change/Add/Removal Detection<a aria-label="Anchor link for: change-add-removal-detection" class=zola-anchor href=#change-add-removal-detection style=visibility:hidden>#</a></h1><p>Another commonly used feature within these ECS libraries is change/add/removal detection. This feature allows you to detect whenever an entities gets a component added onto it or when an entity’s component gets modified. I had to implement such a system to be able to handle procedural system generation, and after 2 iterations, I’ve got it working nicely for my use case. Here’s how I did it:<h2 id=initial-implementation>Initial implementation<a aria-label="Anchor link for: initial-implementation" class=zola-anchor href=#initial-implementation style=visibility:hidden>#</a></h2><p>I first did it naively: I stored 2 <code>u64</code>s (all my component indices use a <code>u64</code> internally) for <code>added</code> / <code>modified</code> components for each of my <code>entities</code>. <em>(I couldn’t handle removal detection due to the fact that it would need to dissociate entities from their components whenever they “hop” archetypes. Didn’t feel like coding that in so I opted with the easier solution of just not doing that lel)</em>. Here's an example of these two <code>u64</code>s that contain the added / changed components (where the first value contains the <em>added</em> components layout bitmask and the second value contains the <em>changed</em> components layout bitmask)<table><thead><tr><th>Archetypes<th>Entities<th>State Masks<tbody><tr><td>0b011<td>[Entity 01]<td>[0b001, 0b010]<tr><td>0b110<td>[Entity 02]<td>[0b010, 0b110]</table><p>So for <code>Entity 01</code>, we have an "added components bitmask layout" of <code>0b001</code> and a "modified components bitmask layout" of <code>0b011</code>. This means that the component with the corresponding <code>id</code> of 0b001 was added onto the entity since last tick, and the component with the corresponding <code>id</code> of <code>0b010</code> () was modified since last tick<p>Inside my <code>Archetype</code>, along-side my <code>entities</code> vector, I also had a <code>state</code> vector that would store these two <code>u64</code>s for each entity within the archetype. I implemented this “filter” system (heavily inspired from Bevy’s filters) that would simply discard iterating over components that do not fit the given criteria based on these two <code>u64s</code>. For example, you could write the following filter:<pre class="language-rs z-code" data-lang=rs><code class=language-rs data-lang=rs><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> ``Bullet`` and ``Velocity`` are both structs that derive the ``Component`` trait
</span><span class="z-storage z-type z-rust">let</span> filter <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-meta z-path z-rust">contains<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span>Bullet<span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-bitwise z-rust">&</span> <span class="z-meta z-path z-rust">modified<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span>Velocity<span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></code></pre><p>which would only iterate over the specified query for entities that have the “Bullet” components and a modified “Velocity” component.<p>The way I implemented this filtering system initially was very slow; I would iterate over my entities, check their state masks and do a bitwise and/or/xor (depending on the filter operation) on those and the new component mask. This is very wasteful because most of the time, those two u64s have only a few bits enabled in total, so a bunch of processing time is lost by computing something that wouldn't affect the final result.<h2 id=column-based-optimization>Column based optimization<a aria-label="Anchor link for: column-based-optimization" class=zola-anchor href=#column-based-optimization style=visibility:hidden>#</a></h2><p>As an optimization, I thought of flipping things around. Instead of storing <code>bitmask</code>s per <code>Entity</code>, how about I store <code>entitie</code>s per <code>bitmask</code>?<p>Instead of storing 2 <code>u64</code>s for each entity, I store the state of each entity’s components in 2<em>x</em> u64s (where <em>x</em> is the number of components the entity has). I basically flipped this row based filtering system into a column based one, which allows me to compute the filter state of up to 64 entities all at once, only for the components that are actually needed.<p>The table below kinda shows this visually. Instead of storing the states for every <em>possible</em> component per entity, I only store the state of the <em>actual</em> components that the entities have (assuming all of these are part of the same archetype). And like the previous table, the first value represents the "added" state . The second value representing the modified state.<table><thead><tr><th>Entities<th>Transform State Bitmask<th>Health State Bitmask<th>Player State Bitmask<tbody><tr><td>Entity 04<td>[0, 0]<td>[1, 1]<td>[1, 1]<tr><td>Entity 05<td>[0, 1]<td>[0, 0]<td>[1, 1]<tr><td>Entity 06<td>[0, 0]<td>[1, 1]<td>[0, 1]</table><p>Since the possible variants for these values is either 0 or 1, we can "flip" the vertical columns into rows, and storing the values as bits inside a <code>u64</code> chunk.<table><thead><tr><th>Entities<th>Added State Chunk<th>Modified State Chunk<tbody><tr><td>Transform State Bitmask<td>0b011<td>0b011<tr><td>Health State Bitmask<td>0b001<td>0b101<tr><td>Player State Bitmask<td>0b010<td>0b011</table><p>I decided to modify the <code>state</code> array in my <code>Archetype</code> to a <code>column state chunk</code> array that contains the component add/modify state of 64 entities all at once <em>(since there are 64 bits in a <code>u64</code> integer)</em> to. I could’ve went with u128, but for now I decided to keep it to a reasonable chunk amount of 64 <em>(I could bump it up to 128 any time I needed anyways, it all makes use of the trait system so it is very easy to just switch to another type that implements the basic bitwise operations without having to rewrite most of the logic)</em>.<p>This sped up things incredibly, without having to complicate the code a bunch, so I’ll take it as a win. As an added bonus, I could now skip over a whole chunk (64) of entities if I know that none of them pass the filter (by simpling counting the number of bits inside the chunked state mask (which on most architectures, is a special instruction: <strong>popcnt</strong>)<h1 id=conclusion>Conclusion<a aria-label="Anchor link for: conclusion" class=zola-anchor href=#conclusion style=visibility:hidden>#</a></h1><p>And after uhhhh… a few <strong>months</strong> of painstaking blood shedding work and relentless nights of debugging non-deterministic tests and undefined behaviors due to manipulating raw pointers... there you go! You’ve got yourself your own proper ECS library! <br> (<em>shoulda used one of the open source ones aaaaa</em>)<p>oh well, at least it was a learning experience amiright ಥ‿ಥ<p>Other great resources that helped me learn ECS:<p><a rel="nofollow noreferrer" href=https://ajmmertens.medium.com/building-an-ecs-2-archetypes-and-vectorization-fe21690805f9>Medium.com article about building an Archetypal Based ECS</a> <br> <a rel="nofollow noreferrer" href=https://www.david-colson.com/2020/02/09/making-a-simple-ecs.html>David Colson's article about making a simple ECS</a> <br> <a rel="nofollow noreferrer" href=https://github.com/skypjack/entt>C++ entt library</a> <br> <a rel="nofollow noreferrer" href=https://github.com/amethyst/specs>Rust specs Crate</a> <br> <a rel="nofollow noreferrer" href=https://docs.rs/hecs/latest/hecs/>Rust hecs crate</a> <br> <a rel="nofollow noreferrer" href=https://docs.rs/bevy_ecs/latest/bevy_ecs/>Rust bevy_ecs crate</a> <br></article><div class=giscus></div></div><footer><div class=copyright><p>Jed037</div><div class=credits>powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>serene</a></div></footer></main></div><script src=/js/lightense.min.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script src=/js/main.js></script>