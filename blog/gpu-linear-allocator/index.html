<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>GPU Compute-based Linear Memory Allocator</title><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,600;1,600&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Prompt:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Roboto+Mono:ital,wght@0,500;1,500&family=Sankofa+Display&display=swap" rel=stylesheet><style>body{--primary-color:#5871a2;--primary-pale-color:#5871a210;--text-color:#3c4043;--text-pale-color:#94969f;--bg-color:#fff;--highlight-mark-color:#5f75b035;--callout-note-color:#5871a2;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460;--main-font:"Roboto Mono",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:"Roboto Mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:768px;--main-max-width:768px;--avatar-size:60px;--icon-size:20px;--homepage-font-size:16px;--homepage-line-height:1.5;--paragraph-font-size:16px;--paragraph-line-height:1.5;--aside-font-size:15px;--img-border-radius:0;--callout-border-radius:0;--detail-border-radius:0;--dark-mode-img-brightness:1.0;--dark-mode-chart-brightness:1.0;--inline-code-border-radius:2px;--inline-code-bg-color:var(--primary-pale-color);--block-code-border-radius:0;--code-font-size:14px;--block-code-border-color:var(--primary-color);--detail-border-color:var(--primary-color)}body.dark{--primary-color:#ce79d6;--primary-pale-color:#8d5dac20;--text-color:#9197a5;--text-pale-color:#747983;--bg-color:#232529;--highlight-mark-color:#5f75b035;--callout-note-color:#ba70d8;--callout-important-color:#9571cf;--callout-warning-color:#babb69;--callout-alert-color:#f36060;--callout-question-color:#477389;--callout-tip-color:#3c8460}</style><link href=/main.css rel=stylesheet><link href=/hl-light.css id=hl rel=stylesheet><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV rel=stylesheet><script crossorigin defer integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script crossorigin defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false},{left:'\\[',right:'\\]',display:true}],throwOnError:false})})</script><body class=post><script>const theme=sessionStorage.getItem('theme');const match=window.matchMedia("(prefers-color-scheme: dark)").matches;if(theme&&theme=='dark'||!theme&&match){document.body.classList.add('dark');const a=document.querySelector('link#hl');if(a)a.href='/hl-dark.css'}</script><header class=blur><div id=header-wrapper><nav><a class=instant href=/>Jed037</a><button aria-label="toggle expand" class=separator id=toggler>::</button><span class="wrap left fold">{</span><a class="instant fold" href=/projects>projects</a><span class="wrap-separator fold">,</span><a class="instant fold" href=/about>about</a><span class="wrap right fold">} ;</span></nav><div id=btns><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>' id=theme-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><div id=wrapper><div id=blank></div><aside><nav><ul><li><a class=h2 href=#intro-determination>Intro & Determination</a><li><a class=h2 href=#the-naive-method>The Naive Method</a><li><a class=h2 href=#part-1-the-main-idea>Part 1: The Main Idea</a><li><a class=h2 href=#pre-requesites-for-dynamic-allocation>Pre-requesites for dynamic allocation</a><li><a class=h2 href=#part-2-gpu-parallel-min-search>Part 2: GPU Parallel min search</a> <ul><li><a class=h3 href=#get-required-memory-block-size>Get required memory block size</a><li><a class=h3 href=#initialize-min-parallel-search>Initialize min parallel search</a><li><a class=h3 href=#find-lowest-chunk-index-actual-search-algo>Find lowest chunk index (actual search algo)</a></ul><li><a class=h2 href=#part-3-temp-memory-perm-memory-copy>Part 3: Temp memory -> Perm memory copy</a><li><a class=h2 href=#conclusion-results>Conclusion & Results</a></ul></nav><button aria-label="back to top" id=back-to-top><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill=currentColor></path></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1>GPU Compute-based Linear Memory Allocator</h1><div id=post-info><div id=date><span id=publish>2024-03-01</span></div><div id=tags><a class=instant href=https://jedjoud10.github.io/tags/game-dev><span>#</span>game-dev</a><a class=instant href=https://jedjoud10.github.io/tags/ecs><span>#</span>ecs</a><a class=instant href=https://jedjoud10.github.io/tags/custom-engine><span>#</span>custom-engine</a></div></div><h1 id=intro-determination>Intro & Determination<a aria-label="Anchor link for: intro-determination" class=zola-anchor href=#intro-determination style=visibility:hidden>#</a></h1><p>Hello! In this short blog post, I will show you how I implemented a custom GPU based linear allocator for one of my unity projects involving custom terrain generation and GPU instancing. One of the main reasons one would want such a GPU allocator is so that they can allocate temporary memory on the GPU without having to readback to the CPU to allocate buffers there. This is because reading back to the CPU to create buffers not only adds a lot of latency, but is also very slow, so when experimenting I decided to leave everything up to the GPU and keep as little as possible on the CPU.<p>I have implemented this sorts of GPU allocator twice already, once for my custom game engine, and once for the unity project I work on. Both of these projects needed some sort of GPU allocation algorithm to allocate GPU memory with minimal read back to the CPU.<h1 id=the-naive-method>The Naive Method<a aria-label="Anchor link for: the-naive-method" class=zola-anchor href=#the-naive-method style=visibility:hidden>#</a></h1><p>The first method I thought of to implement such a system would be to simply read back the temporary memory data to the CPU, and manually copy it to a free spot within the big buffer. However, even before implementing such a thing, I knew that it would be <em>extremely</em> bad for performance due the latency and limited transfer bus for GPU -> CPU readback. Not only that, but it would seem wasteful to generate a lot of data extremely fast on the GPU to then read it back on the slow CPU to be able to upload it once again to the GPU. It just didn't seem like a very fast method to achieve what I wanted at respectable framerates, which is why this pushed me to implement my own custom linear GPU allocator<h1 id=part-1-the-main-idea>Part 1: The Main Idea<a aria-label="Anchor link for: part-1-the-main-idea" class=zola-anchor href=#part-1-the-main-idea style=visibility:hidden>#</a></h1><p>The big idea of such an allocator would be that it would be able to copy my temporary memory (from my temp buffer) to a permanent memory <strong>without</strong> overlapping or overwriting any data already present in the permanent buffer. It should also be possible to <em>know</em> where it copied previous blocks so that we are able to remove them afterwards (analogous to deallocating memory).<p>So these are the following restrictions for such an allocator:<ul><li><strong>Most of the work on the GPU with minimal data transfer to CPU</strong><li><strong>Relatively fast to allocate new memory chunks</strong><li><strong>Both GPU and CPU should know what memory chunks are currently in use</strong><li><strong>No overlapping / overwriting of old chunks</strong></ul><p>So with these restrictions I've set out to implement a simple linear allocator with a CPU/GPU bitset to allow us to know what chunks are currently in use (where each "chunk" is just a region of 4kb memory, so that we don't need to allocate each byte individually, which would be horrendously slow).<p>In my most recent implementation of this algorithm, I have 4 distinct compute shaders that run sequentially to ensure proper memory allocation:<ol><li>Free memory chunk finder (find a free memory chunk linearly)<li>Memory chunk copy (copy temp memory to perm memory block)<li>Memory chunk removal (deallocating)</ol><h1 id=pre-requesites-for-dynamic-allocation>Pre-requesites for dynamic allocation<a aria-label="Anchor link for: pre-requesites-for-dynamic-allocation" class=zola-anchor href=#pre-requesites-for-dynamic-allocation style=visibility:hidden>#</a></h1><p>Before we even tackle dynamic allocation, we must understand that this method of allocating memory is limited by the amount of VRAM that our GPU has. In my case, I have a GTX 1050 mobile with 3GB VRAM, and the maximum buffer size I can possibly allocate in Vulkan is 2GB, however after a lot of testing I've figured out that it is best to allocate 4 or less buffers of 512 megabytes. In my Unity implementation for example, I just have one big buffer that contains a few megabytes of data since prop generation doesn't take that much memory.<h1 id=part-2-gpu-parallel-min-search>Part 2: GPU Parallel min search<a aria-label="Anchor link for: part-2-gpu-parallel-min-search" class=zola-anchor href=#part-2-gpu-parallel-min-search style=visibility:hidden>#</a></h1><p>The first step in allocating memory on the GPU is to find a free block of memory. In my implementations I did this both on the CPU and on the GPU so that I can keep a copy of my indices on the CPU since I will need to be able to remove (aka deallocate) chunks of memory later on.<p>To store what chunks are currently allocated and in use I simply make use of dynamically allocated bitset where each bit repsents a "sub-allocation". (<em>in my unity terrain generator each bit simply represents a prop since I haven't implement sub-allocations yet</em>). This allows me to run a fast algorithm to detect what regions in memory are not being in use and ones that we could allocate. In both my implementations, I created a compute shader that handles this task, and this is its source code and how it works:<pre class="language-glsl z-code" data-lang=glsl><code class=language-glsl data-lang=glsl><span class="z-source z-glsl"><span class="z-meta z-preprocessor z-macro z-glsl"><span class="z-keyword z-control z-import z-version z-glsl">#version</span></span><span class="z-meta z-preprocessor z-macro z-glsl"> 460 <span class="z-entity z-name z-constant z-preprocessor z-glsl">core</span></span>
<span class="z-storage z-modifier z-glsl">layout</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>local_size_x <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">128</span><span class="z-punctuation z-separator z-glsl">,</span> local_size_y <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-separator z-glsl">,</span> local_size_z <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-storage z-modifier z-glsl">in</span><span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Spec constants for sizes
</span><span class="z-storage z-modifier z-glsl">layout</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>constant_id <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-storage z-modifier z-glsl">const</span> <span class="z-storage z-type z-glsl">uint</span> sub_allocations <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-storage z-modifier z-glsl">layout</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>constant_id <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-storage z-modifier z-glsl">const</span> <span class="z-storage z-type z-glsl">uint</span> vertices_per_sub_allocation <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-storage z-modifier z-glsl">layout</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>constant_id <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">2</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-storage z-modifier z-glsl">const</span> <span class="z-storage z-type z-glsl">uint</span> triangles_per_sub_allocation <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Each group consists of 128 sub allocations
</span><span class="z-storage z-modifier z-glsl">const</span> <span class="z-storage z-type z-glsl">uint</span> sub_allocation_groups <span class="z-keyword z-operator z-assignment z-glsl">=</span> sub_allocations <span class="z-keyword z-operator z-arithmetic z-glsl">/</span> <span class="z-constant z-numeric z-glsl">128</span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-storage z-modifier z-glsl">const</span> <span class="z-storage z-type z-glsl">uint</span> sub_allocations_per_sub_allocation_group <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">128</span><span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Sub allocation chunk indices
</span><span class="z-storage z-modifier z-glsl">layout</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>std430<span class="z-punctuation z-separator z-glsl">,</span> set <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-separator z-glsl">,</span> binding <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-storage z-modifier z-glsl">buffer</span> SubAllocationChunkIndices <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
    <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-brackets z-glsl"><span class="z-punctuation z-section z-brackets z-begin z-glsl">[</span>sub_allocations<span class="z-punctuation z-section z-brackets z-end z-glsl">]</span></span> data<span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-punctuation z-section z-block z-end z-glsl">}</span></span> indices<span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Allocation offsets
</span><span class="z-storage z-modifier z-glsl">layout</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>std430<span class="z-punctuation z-separator z-glsl">,</span> set <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-separator z-glsl">,</span> binding <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-storage z-modifier z-glsl">buffer</span> FoundOffsets <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
    <span class="z-storage z-type z-glsl">uint</span> vertices<span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-storage z-type z-glsl">uint</span> triangles<span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-punctuation z-section z-block z-end z-glsl">}</span></span> offsets<span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Atomic counters
</span><span class="z-storage z-modifier z-glsl">layout</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>std430<span class="z-punctuation z-separator z-glsl">,</span> set <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-separator z-glsl">,</span> binding <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">2</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-storage z-modifier z-glsl">readonly</span> <span class="z-storage z-modifier z-glsl">buffer</span> Counters <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
    <span class="z-storage z-type z-glsl">uint</span> vertices<span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-storage z-type z-glsl">uint</span> triangles<span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-punctuation z-section z-block z-end z-glsl">}</span></span> counters<span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Must be shared for atomic ops between groups
</span><span class="z-storage z-modifier z-glsl">shared</span> <span class="z-storage z-type z-glsl">uint</span> chosen_sub_allocation_index<span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Sub-allocations:         [-1] [-1] [3] [3] [3] [-1] [2] [2]
</span><span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Sub-allocation groups:   [                                ]
</span><span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Dispatch invocations are sub allocation groups
</span><span class="z-storage z-type z-glsl">void</span> <span class="z-meta z-function z-glsl"><span class="z-entity z-name z-function z-glsl">main</span></span><span class="z-meta z-function z-parameters z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function z-parameters z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-meta z-function z-glsl"> </span><span class="z-meta z-function z-glsl"><span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span></span></span><span class="z-meta z-function z-glsl"><span class="z-meta z-block z-glsl">
    <span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>gl_GlobalInvocationID<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">x</span> <span class="z-keyword z-operator z-comparison z-glsl">></span> sub_allocation_groups<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
        <span class="z-keyword z-control z-glsl">return</span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Checks if we are within a free region or not
</span>    <span class="z-storage z-type z-glsl">bool</span> within_free <span class="z-keyword z-operator z-assignment z-glsl">=</span> false<span class="z-punctuation z-terminator z-glsl">;</span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Keeps count of the number of empty sub allocations that we passed through 
</span>    <span class="z-storage z-type z-glsl">uint</span> free_sub_allocations <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-terminator z-glsl">;</span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Length of what we need to find sub allocs for
</span>    <span class="z-storage z-type z-glsl">uint</span> vertices <span class="z-keyword z-operator z-assignment z-glsl">=</span> counters<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">vertices</span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-storage z-type z-glsl">uint</span> triangles <span class="z-keyword z-operator z-assignment z-glsl">=</span> counters<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">triangles</span><span class="z-punctuation z-terminator z-glsl">;</span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Doesn't really matter since we can calculate it anyways 
</span>    <span class="z-storage z-type z-glsl">uint</span> vertex_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-meta z-function-call z-glsl"><span class="z-support z-function z-glsl">ceil</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-storage z-type z-glsl">float</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>vertices<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-keyword z-operator z-arithmetic z-glsl">/</span> <span class="z-storage z-type z-glsl">float</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>vertices_per_sub_allocation<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-storage z-type z-glsl">uint</span> triangle_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-meta z-function-call z-glsl"><span class="z-support z-function z-glsl">ceil</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-storage z-type z-glsl">float</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>triangles<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-keyword z-operator z-arithmetic z-glsl">/</span> <span class="z-storage z-type z-glsl">float</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>triangles_per_sub_allocation<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-storage z-type z-glsl">uint</span> chosen_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-meta z-function-call z-glsl"><span class="z-support z-function z-glsl">max</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl">vertex_sub_allocation_count<span class="z-punctuation z-separator z-glsl">,</span> triangle_sub_allocation_count</span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-storage z-type z-glsl">uint</span> reason <span class="z-keyword z-operator z-assignment z-glsl">=</span> vertex_sub_allocation_count <span class="z-keyword z-operator z-comparison z-glsl">></span> triangle_sub_allocation_count ? <span class="z-constant z-numeric z-glsl">2</span> : <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-terminator z-glsl">;</span> 

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Temp values for now 
</span>    <span class="z-storage z-type z-glsl">uint</span> temp_sub_allocation_index <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-storage z-type z-glsl">uint</span> temp_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-terminator z-glsl">;</span>

    <span class="z-storage z-type z-glsl">uint</span> invocation_local_chosen_sub_alloction_index <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-terminator z-glsl">;</span>

    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">memoryBarrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">barrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> If we are the first group, update temporarily
</span>    <span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>gl_GlobalInvocationID<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">x</span> <span class="z-keyword z-operator z-comparison z-glsl">==</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
        <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">atomicExchange</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl">chosen_sub_allocation_index<span class="z-punctuation z-separator z-glsl">,</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-keyword z-operator z-arithmetic z-glsl">-</span><span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>

    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">memoryBarrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">barrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Find a free memory range for this specific sub-allocation group
</span>    <span class="z-storage z-type z-glsl">uint</span> base <span class="z-keyword z-operator z-assignment z-glsl">=</span> gl_GlobalInvocationID<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">x</span> <span class="z-keyword z-operator z-glsl">*</span> sub_allocations_per_sub_allocation_group<span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-keyword z-control z-glsl">for</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-storage z-type z-glsl">uint</span> i <span class="z-keyword z-operator z-assignment z-glsl">=</span> base<span class="z-punctuation z-terminator z-glsl">;</span> i <span class="z-keyword z-operator z-comparison z-glsl"><</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>base <span class="z-keyword z-operator z-arithmetic z-glsl">+</span> sub_allocations_per_sub_allocation_group<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span> i<span class="z-keyword z-operator z-arithmetic z-glsl">+</span><span class="z-keyword z-operator z-arithmetic z-glsl">+</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
        <span class="z-storage z-type z-glsl">bool</span> free <span class="z-keyword z-operator z-assignment z-glsl">=</span> indices<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">data</span><span class="z-meta z-brackets z-glsl"><span class="z-punctuation z-section z-brackets z-begin z-glsl">[</span>i<span class="z-punctuation z-section z-brackets z-end z-glsl">]</span></span> <span class="z-keyword z-operator z-comparison z-glsl">==</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-keyword z-operator z-arithmetic z-glsl">-</span><span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span>
        
        <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> We just moved into a free allocation
</span>        <span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-keyword z-operator z-arithmetic z-glsl">!</span>within_free <span class="z-keyword z-operator z-arithmetic z-glsl">&&</span> free<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
            temp_sub_allocation_index <span class="z-keyword z-operator z-assignment z-glsl">=</span> i<span class="z-punctuation z-terminator z-glsl">;</span>
            temp_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-terminator z-glsl">;</span>
            within_free <span class="z-keyword z-operator z-assignment z-glsl">=</span> true<span class="z-punctuation z-terminator z-glsl">;</span>
        <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>

        <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> We stayed within a free allocation
</span>        <span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>within_free <span class="z-keyword z-operator z-arithmetic z-glsl">&&</span> free<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
            temp_sub_allocation_count <span class="z-keyword z-operator z-assignment z-augmented z-glsl">+=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-terminator z-glsl">;</span>
        <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>
        
        <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> If this is a possible candidate for a memory alloc offset, then use it
</span>        <span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>within_free <span class="z-keyword z-operator z-arithmetic z-glsl">&&</span> temp_sub_allocation_count <span class="z-keyword z-operator z-comparison z-glsl">>=</span> chosen_sub_allocation_count<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
            <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">atomicMin</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl">chosen_sub_allocation_index<span class="z-punctuation z-separator z-glsl">,</span> temp_sub_allocation_index</span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
            invocation_local_chosen_sub_alloction_index <span class="z-keyword z-operator z-assignment z-glsl">=</span> temp_sub_allocation_index<span class="z-punctuation z-terminator z-glsl">;</span>
            <span class="z-keyword z-control z-glsl">break</span><span class="z-punctuation z-terminator z-glsl">;</span>
        <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>

        <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Update to take delta
</span>        within_free <span class="z-keyword z-operator z-assignment z-glsl">=</span> free<span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>

    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">memoryBarrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">barrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Only let one invocation do this shit
</span>    <span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>gl_GlobalInvocationID<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">x</span> <span class="z-keyword z-operator z-arithmetic z-glsl">!</span><span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
        <span class="z-keyword z-control z-glsl">return</span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span> 

    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">memoryBarrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">barrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> After finding the right block, we can write to it
</span>    <span class="z-keyword z-control z-glsl">for</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-storage z-type z-glsl">uint</span> i <span class="z-keyword z-operator z-assignment z-glsl">=</span> chosen_sub_allocation_index<span class="z-punctuation z-terminator z-glsl">;</span> i <span class="z-keyword z-operator z-comparison z-glsl"><</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>chosen_sub_allocation_index <span class="z-keyword z-operator z-arithmetic z-glsl">+</span> chosen_sub_allocation_count<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span> i<span class="z-keyword z-operator z-arithmetic z-glsl">+</span><span class="z-keyword z-operator z-arithmetic z-glsl">+</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
        indices<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">data</span><span class="z-meta z-brackets z-glsl"><span class="z-punctuation z-section z-brackets z-begin z-glsl">[</span>i<span class="z-punctuation z-section z-brackets z-end z-glsl">]</span></span> <span class="z-keyword z-operator z-assignment z-glsl">=</span> reason<span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Offsets that we will write eventually
</span>    offsets<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">vertices</span> <span class="z-keyword z-operator z-assignment z-glsl">=</span> chosen_sub_allocation_index <span class="z-keyword z-operator z-glsl">*</span> vertices_per_sub_allocation<span class="z-punctuation z-terminator z-glsl">;</span>
    offsets<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">triangles</span> <span class="z-keyword z-operator z-assignment z-glsl">=</span> chosen_sub_allocation_index <span class="z-keyword z-operator z-glsl">*</span> triangles_per_sub_allocation<span class="z-punctuation z-terminator z-glsl">;</span>
</span></span><span class="z-meta z-function z-glsl"><span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-end z-glsl">}</span></span></span>
</span></code></pre><p>That's quite a lot of code so lemme break it down for you. Basically, there are 3 steps that occur within this <code>find.comp</code> compute shader<ol><li>Get required memory block size to allocate<li>Initialize min parallel search<li>Find lowest chunk index to reduce fragmentation (<em>fun part</em>)</ol><h2 id=get-required-memory-block-size>Get required memory block size<a aria-label="Anchor link for: get-required-memory-block-size" class=zola-anchor href=#get-required-memory-block-size style=visibility:hidden>#</a></h2><p>What this basically means is that we just need to know how <em>much</em> memory we should allocate. This should be a trivial matter since we are using this dynamic allocate for a reason; allocating dynamic memory! So this step, in most if not all cases, is already done. In my code it's a bit more complicated since I actually allocate two buffers at once (<em>for my vertices and triangles</em>) but that's basically what this code does.<pre class="language-glsl z-code" data-lang=glsl><code class=language-glsl data-lang=glsl><span class="z-source z-glsl"><span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Length of what we need to find sub allocs for
</span><span class="z-storage z-type z-glsl">uint</span> vertices <span class="z-keyword z-operator z-assignment z-glsl">=</span> counters<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">vertices</span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-storage z-type z-glsl">uint</span> triangles <span class="z-keyword z-operator z-assignment z-glsl">=</span> counters<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">triangles</span><span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Doesn't really matter since we can calculate it anyways 
</span><span class="z-storage z-type z-glsl">uint</span> vertex_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-meta z-function-call z-glsl"><span class="z-support z-function z-glsl">ceil</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-storage z-type z-glsl">float</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>vertices<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-keyword z-operator z-arithmetic z-glsl">/</span> <span class="z-storage z-type z-glsl">float</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>vertices_per_sub_allocation<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-storage z-type z-glsl">uint</span> triangle_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-meta z-function-call z-glsl"><span class="z-support z-function z-glsl">ceil</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-storage z-type z-glsl">float</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>triangles<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-keyword z-operator z-arithmetic z-glsl">/</span> <span class="z-storage z-type z-glsl">float</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>triangles_per_sub_allocation<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-storage z-type z-glsl">uint</span> chosen_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-meta z-function-call z-glsl"><span class="z-support z-function z-glsl">max</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl">vertex_sub_allocation_count<span class="z-punctuation z-separator z-glsl">,</span> triangle_sub_allocation_count</span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-storage z-type z-glsl">uint</span> reason <span class="z-keyword z-operator z-assignment z-glsl">=</span> vertex_sub_allocation_count <span class="z-keyword z-operator z-comparison z-glsl">></span> triangle_sub_allocation_count ? <span class="z-constant z-numeric z-glsl">2</span> : <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-terminator z-glsl">;</span> 
</span></code></pre><h2 id=initialize-min-parallel-search>Initialize min parallel search<a aria-label="Anchor link for: initialize-min-parallel-search" class=zola-anchor href=#initialize-min-parallel-search style=visibility:hidden>#</a></h2><p>Just initialize some global and thread local variables to make use of GPU parallelisation. Basically the following lines<pre class="language-glsl z-code" data-lang=glsl><code class=language-glsl data-lang=glsl><span class="z-source z-glsl"><span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Must be shared for atomic ops between groups
</span><span class="z-storage z-modifier z-glsl">shared</span> <span class="z-storage z-type z-glsl">uint</span> chosen_sub_allocation_index<span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Temp values for now 
</span><span class="z-storage z-type z-glsl">uint</span> temp_sub_allocation_index <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-storage z-type z-glsl">uint</span> temp_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-storage z-type z-glsl">uint</span> invocation_local_chosen_sub_alloction_index <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Checks if we are within a free region or not
</span><span class="z-storage z-type z-glsl">bool</span> within_free <span class="z-keyword z-operator z-assignment z-glsl">=</span> false<span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Keeps count of the number of empty sub allocations that we passed through 
</span><span class="z-storage z-type z-glsl">uint</span> free_sub_allocations <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">memoryBarrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">barrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>

<span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> If we are the first group, update temporarily
</span><span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>gl_GlobalInvocationID<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">x</span> <span class="z-keyword z-operator z-comparison z-glsl">==</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">atomicExchange</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl">chosen_sub_allocation_index<span class="z-punctuation z-separator z-glsl">,</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-keyword z-operator z-arithmetic z-glsl">-</span><span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>

<span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">memoryBarrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">barrier</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
</span></code></pre><h2 id=find-lowest-chunk-index-actual-search-algo>Find lowest chunk index (actual search algo)<a aria-label="Anchor link for: find-lowest-chunk-index-actual-search-algo" class=zola-anchor href=#find-lowest-chunk-index-actual-search-algo style=visibility:hidden>#</a></h2><p>This is the actual search algorithm. It is very stupid and naive, but it seems to work at reasonable performance in my engine. What I do is simply loop over all the chunks in multiple GPU invocations as to look for an empty chunk of memory in parallel.<pre class="language-glsl z-code" data-lang=glsl><code class=language-glsl data-lang=glsl><span class="z-source z-glsl"><span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Find a free memory range for this specific sub-allocation group
</span><span class="z-storage z-type z-glsl">uint</span> base <span class="z-keyword z-operator z-assignment z-glsl">=</span> gl_GlobalInvocationID<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">x</span> <span class="z-keyword z-operator z-glsl">*</span> sub_allocations_per_sub_allocation_group<span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-keyword z-control z-glsl">for</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-storage z-type z-glsl">uint</span> i <span class="z-keyword z-operator z-assignment z-glsl">=</span> base<span class="z-punctuation z-terminator z-glsl">;</span> i <span class="z-keyword z-operator z-comparison z-glsl"><</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>base <span class="z-keyword z-operator z-arithmetic z-glsl">+</span> sub_allocations_per_sub_allocation_group<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span> i<span class="z-keyword z-operator z-arithmetic z-glsl">+</span><span class="z-keyword z-operator z-arithmetic z-glsl">+</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
    <span class="z-storage z-type z-glsl">bool</span> free <span class="z-keyword z-operator z-assignment z-glsl">=</span> indices<span class="z-punctuation z-accessor z-glsl">.</span><span class="z-variable z-other z-member z-glsl">data</span><span class="z-meta z-brackets z-glsl"><span class="z-punctuation z-section z-brackets z-begin z-glsl">[</span>i<span class="z-punctuation z-section z-brackets z-end z-glsl">]</span></span> <span class="z-keyword z-operator z-comparison z-glsl">==</span> <span class="z-storage z-type z-glsl">uint</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-keyword z-operator z-arithmetic z-glsl">-</span><span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    
    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> We just moved into a free allocation
</span>    <span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span><span class="z-keyword z-operator z-arithmetic z-glsl">!</span>within_free <span class="z-keyword z-operator z-arithmetic z-glsl">&&</span> free<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
        temp_sub_allocation_index <span class="z-keyword z-operator z-assignment z-glsl">=</span> i<span class="z-punctuation z-terminator z-glsl">;</span>
        temp_sub_allocation_count <span class="z-keyword z-operator z-assignment z-glsl">=</span> <span class="z-constant z-numeric z-glsl">0</span><span class="z-punctuation z-terminator z-glsl">;</span>
        within_free <span class="z-keyword z-operator z-assignment z-glsl">=</span> true<span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> We stayed within a free allocation
</span>    <span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>within_free <span class="z-keyword z-operator z-arithmetic z-glsl">&&</span> free<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
        temp_sub_allocation_count <span class="z-keyword z-operator z-assignment z-augmented z-glsl">+=</span> <span class="z-constant z-numeric z-glsl">1</span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>
    
    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> If this is a possible candidate for a memory alloc offset, then use it
</span>    <span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>within_free <span class="z-keyword z-operator z-arithmetic z-glsl">&&</span> temp_sub_allocation_count <span class="z-keyword z-operator z-comparison z-glsl">>=</span> chosen_sub_allocation_count<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
        <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">atomicMin</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl">chosen_sub_allocation_index<span class="z-punctuation z-separator z-glsl">,</span> temp_sub_allocation_index</span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
        invocation_local_chosen_sub_alloction_index <span class="z-keyword z-operator z-assignment z-glsl">=</span> temp_sub_allocation_index<span class="z-punctuation z-terminator z-glsl">;</span>
        <span class="z-keyword z-control z-glsl">break</span><span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>

    <span class="z-comment z-line z-double-slash z-glsl"><span class="z-punctuation z-definition z-comment z-glsl">//</span> Update to take delta
</span>    within_free <span class="z-keyword z-operator z-assignment z-glsl">=</span> free<span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>
</span></code></pre><p>So within the many parallel GPU invocations, I do a sequential linear search to find a region of blocks of <code>n</code> size so that we can use it for our permanent memory allocation<pre class="language-glsl z-code" data-lang=glsl><code class=language-glsl data-lang=glsl><span class="z-source z-glsl"><span class="z-keyword z-control z-glsl">if</span> <span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span>within_free <span class="z-keyword z-operator z-arithmetic z-glsl">&&</span> temp_sub_allocation_count <span class="z-keyword z-operator z-comparison z-glsl">>=</span> chosen_sub_allocation_count<span class="z-punctuation z-section z-group z-end z-glsl">)</span></span> <span class="z-meta z-block z-glsl"><span class="z-punctuation z-section z-block z-begin z-glsl">{</span>
    <span class="z-meta z-function-call z-glsl"><span class="z-variable z-function z-glsl">atomicMin</span><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-begin z-glsl">(</span></span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl">chosen_sub_allocation_index<span class="z-punctuation z-separator z-glsl">,</span> temp_sub_allocation_index</span></span><span class="z-meta z-function-call z-glsl"><span class="z-meta z-group z-glsl"><span class="z-punctuation z-section z-group z-end z-glsl">)</span></span></span><span class="z-punctuation z-terminator z-glsl">;</span>
    invocation_local_chosen_sub_alloction_index <span class="z-keyword z-operator z-assignment z-glsl">=</span> temp_sub_allocation_index<span class="z-punctuation z-terminator z-glsl">;</span>
    <span class="z-keyword z-control z-glsl">break</span><span class="z-punctuation z-terminator z-glsl">;</span>
<span class="z-punctuation z-section z-block z-end z-glsl">}</span></span>
</span></code></pre><p>these lines are really important, as they avoid one big problem of such a system; <code>fragmentation</code> Since we look for empty chunks in parallel, there are many cases in which we <em>find</em> many empty chunks candidates, but they're all scattered around the memory heap. So I implement this <code>atomicMin</code> to find the <em>lowest</em> index and the region that is closest to the start of the GPU buffer. This reduces fragmentation which allows us to allocate memory more efficiently.<p>Here's a picture of the debug view of the allocate in cFlake engine. As you can see, most white chunks are at the start of the buffer, and there aren't any at the end of the buffer, which is what we want. <img alt="Allocator Debug View in cFlake Engine" src=/terrain_allocations_debug.png><h1 id=part-3-temp-memory-perm-memory-copy>Part 3: Temp memory -> Perm memory copy<a aria-label="Anchor link for: part-3-temp-memory-perm-memory-copy" class=zola-anchor href=#part-3-temp-memory-perm-memory-copy style=visibility:hidden>#</a></h1><blockquote class="callout note"><div class=icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" fill=currentColor></path></svg></div><div class=content><p><strong>Edit</strong><p>Ok I just checked the Vulkan extension lookup (March 24th 2024) for my GPU and I found that there is a <code>VK_NV_copy_memory_indirect</code> extension that does the stuff that I will explained below, without actually having to implement it in a custom compute shader. You could probably skip the following text and use the extension instead but at the time of writing this for my engine I didn't know this extension was available (and even if it was, I wouldn't be able to use it since I used wgpu, unless I do some sort of Vulkan/wgpu interop)</div></blockquote><p>This is actually the simplest part of the allocator, and its role is to simply copy the temporary memory we wish to allocate into the chunks we just allocated. Simply like <code>memcpy</code>-ing into a <code>malloc</code>. In of itself, this task is extremely simple; just run a compute shader with a specific size that will copy the memory from one region to another region; the tricky part is that you must decide on the size of the dispatch call for such a compute shader. In all my previous implementations, I went with the naive but easy way of just calling a few dispatches with massive loops inside the compute shader itself, however one could make this a lot more optimized by using indirect dispatch instead but I haven't found any bottlenecks yet so I'm not going to bother.<h1 id=conclusion-results>Conclusion & Results<a aria-label="Anchor link for: conclusion-results" class=zola-anchor href=#conclusion-results style=visibility:hidden>#</a></h1><p>So, as far as results go, this whole allocator works pretty darn nicely. I haven't profiled it but I can assume it's relatively fast. The combination of using bitwise ops and having a "minimum" allocation size (governed by the sub-allocation size) keeps things relatively simple too.<p>As I said before, I've used this in both my custom rust game engine <a rel="nofollow noreferrer" href=https://github.com/jedjoud10/cflake-engine>cFlake</a> for terrain mesh generation and in my <a rel="nofollow noreferrer" href=https://github.com/jedjoud10/VoxelTerrainGenerator>Voxel Unity Package</a> to handle prop generation, and in both cases it worked pretty flawlessly.<p>The only problems I encountered with this if I recall where sometimes data would overwrite / overlap itself when there is no more space to write to (this mostly happened in my unity prop generator). This happens because I have no fallback that gives out an error in that implementation, but I did in my custom engine I think.</article><div class=giscus></div></div><footer><div class=copyright><p>Jed037</div><div class=credits>powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>serene</a></div></footer></main></div><script src=/js/lightense.min.js></script><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script src=/js/main.js></script>